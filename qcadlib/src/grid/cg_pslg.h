/****************************************************************************
**
** Copyright (C) 2007-2008 Cogenda. All rights reserved.
**
** This file is part of the qcadlib Library project.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid qcadlib Professional Edition licenses may use
** this file in accordance with the qcadlib Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
**********************************************************************/

#ifndef __cg_pslg_h__
#define __cg_pslg_h__

#include <vector>
#include <map>

#include "rs_vector.h"
#include "rs_string.h"
#include "rs_spline.h"
#include "rs_hatch.h"

class RS_Graphic;


struct CG_Constrain
{
  RS_Vector p1, p2;
  double char_length;
};

struct CG_Segment
{
  unsigned int p1, p2;
  int mark;
};


struct CG_Region
{
  double x;
  double y;
  double area_control;
  RS_String label;
  RS_String material;
  RS_Hatch * hatch;
  std::vector<RS_Vector> contour_points;
  void add_point(const RS_Vector &p)
  {
    for(unsigned int n=0; n<contour_points.size(); ++n)
      if((contour_points[n]-p).magnitude()<1e-4) return;
    contour_points.push_back(p);
  }
};

struct CG_Hole
{
  double x;
  double y;
};

class CG_PSLG
{
public:
  CG_PSLG(RS_Graphic *);

  std::vector<RS_Vector> & get_points()
  { return _points; }

  std::vector<RS_Vector> & get_aux_points()
  { return _aux_points; }

  std::vector<CG_Segment> & get_segments()
  { return _segments; }

  std::map<int, RS_String> & get_segments_info()
  { return _mark_to_label; }

  std::vector<CG_Region> & get_regions()
  { return _regions; }

  std::vector<CG_Hole> &   get_holes()
  { return _holes; }

  std::vector<CG_Constrain> & get_constrain()
  { return _constrains; }

  RS_String get_region_label(unsigned int r)
  { return _regions[r].label; }

  RS_String get_region_material(unsigned int r)
  { return _regions[r].material; }

  RS_String get_segment_label(unsigned int s)
  { return _mark_to_label[s]; }

  std::vector<RS_Entity *> get_entities_by_mark(int mark)
  {
    std::vector<RS_Entity *> entities;
    typedef std::multimap<int, RS_Entity *>::iterator It;
    std::pair<It, It> pos = _mark_to_entity.equal_range(mark);
    for(It it=pos.first; it!=pos.second; ++it)
      entities.push_back(it->second);
    return entities;
  }

  /**
   * add aux point
   */
  bool add_aux_point(const RS_Vector &v);

  /**
   * add aux point with near boundary check
   */
  bool add_aux_point(const RS_Vector &v, double segment_dist);

private:
  /**
   * build PSLG from visitable Entities in current layer
   */
  void convert_cad_to_pslg(RS_Graphic *);

  /**
   * function to add point into PSLG, drop any overlaped points
   */
  unsigned int add_point(const RS_Vector &v);

  struct RS_Vector_Less
  {
     bool operator() (const RS_Vector &v1, const RS_Vector &v2) const
     {
       return v1.absolute_fuzzy_less(v2, 1e-6);
     }
  };

  /**
   * PSLG points
   */
  std::vector<RS_Vector> _points;

  /**
   * use map to avoid duplicate point
   */
  std::map<RS_Vector, unsigned int, RS_Vector_Less> _points_map;

  /**
   * PSLG aux points (generated by quadtree)
   */
  std::vector<RS_Vector> _aux_points;



  /**
   * PSLG segments
   */
  std::vector<CG_Segment> _segments;

  /**
   * map segment label to mark
   */
  std::map<RS_String, int> _label_to_mark;

  /**
   * map mark to segment label
   */
  std::map<int, RS_String> _mark_to_label;

  /**
   * map mark to RS_Entity,
   * since several entities may have the same label, we have to use multimap here.
   */
  std::multimap<int, RS_Entity *> _mark_to_entity;

  /**
   * PSLG region
   */
  std::vector<CG_Region> _regions;

  /**
   * PSLG hole
   */
  std::vector<CG_Hole> _holes;

  /**
   * area constrain along line
   */
  std::vector<CG_Constrain> _constrains;
};

#endif

